#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

static struct __attribute__((packed)) {
    char prefix[32];
    char datefmt[32];
    char cmd[64];
} cmd = {"date: ", "\%Y-\%m-\%d \%H:\%M:\%S", "/home/binary/code/chapter11/date"};

/**
 * @brief ip, port로 socket 서버를 open한다
 * @param node ip address
 * @param service port
 * @return 서버의 소켓 file descriptor
*/
int open_socket(const char *node, const char *service);

/**
 * @brief buf의 내용을 참고하여 child process로 새로운 프로그램을 시작한다.
 * @param buf 실행할때 참고할 버퍼
 * @return 새로 생성된 프로그램의 child process로부터 읽는 pipe
*/
int exec_cmd(char *buf);

int open_socket(const char *node, const char *service) {
    struct addrinfo hints, *res;
    int sockfd;

    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_DGRAM;
    hints.ai_flags = AI_PASSIVE;
    if (getaddrinfo(NULL, "9999", &hints, &res) != 0) {
        return -1;
    }

    if ((sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) < 0) {
        return -1;
    }
    if (bind(sockfd, res->ai_addr, res->ai_addrlen) < 0) {
        return -1;
    }

    return sockfd;
}

int exec_cmd(char *buf) {
    int pid;
    int p[2]; //p[0] : read , p[1] : write
    size_t i;
    char *argv[3];

    for (i = 0; i < strlen(buf); i++) {//여기서 Bof 공격 발생 가능
        if (buf[i] == '\n') {
            cmd.prefix[i] = '\0';
            break;
        }
        /**
         * @brief 암묵적 제어흐름 : buf가 cmd.prefix에 직접적으로 오염시키지는 않으나, c를 통해 간접적으로 오염 시키고있음
        */
        char c = 0;
        while(c < buf[i]) c++;
        cmd.prefix[i] = c;
    }

    argv[0] = cmd.cmd;
    argv[1] = cmd.datefmt;
    argv[2] = NULL;

    if (pipe(p) < 0) {//open pipe
        perror("(execve-test) failed to open pipe");
        return -1;
    }

    switch (pid = fork()) {
        case -1: /* Error */
            perror("(execve-test) fork failed");
            return -1;
        case 0: /* Child */
            printf("(execve-test/child) execv: %s %s\n", argv[0], argv[1]);
            fflush(stdout);

            close(1);//close stdout
            dup(p[1]);//가장 낮은 번호의 사용되지 않는 fd와 p[1](write)를 복사한다.
            close(p[0]);//close read pipe

            printf("%s", cmd.prefix);
            fflush(stdout);
            execv(argv[0], argv);//execv(cmd, argv...);
            //정상적으로 실행 했다면 오류 x
            perror("(execve-test/child) execve failed");
            kill(getppid(), SIGINT);
            exit(1);
        default: /* Parent */
            close(p[1]);//close write pipe
            return p[0];//return read pipe
    }
    return -1;
}

int main(int argc, char *argv[]) {
    char buf[4096];
    struct sockaddr_storage addr;

    int sockfd = open_socket("localhost", "9999");

    socklen_t addrlen = sizeof(addr);
    recvfrom(sockfd, buf, sizeof(buf), 0, (struct sockaddr *)&addr, &addrlen);

    int child_fd /*read pipe*/ = exec_cmd(buf);
    FILE *fp = fdopen(child_fd, "r");

    while (fgets(buf, sizeof(buf), fp)) {
        sendto(sockfd, buf, strlen(buf) + 1, 0, (struct sockaddr *)&addr, addrlen);
    }
    return 0;
}