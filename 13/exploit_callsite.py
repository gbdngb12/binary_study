#!/usr/bin/env python2
# -*- coding: utf-8 -*-

import triton
import pintool

taintedCallsite = 0x400bef  # 앞선 DTA단계에서 찾아둔 주소값(취약한 간접 호출 지점)
target = 0x400b3b  # 호출을 변경할 목표 주소값

Triton = pintool.getTritonContext()

# main함수 실행 전에 후킹 하므로 argc, argv를 후킹한다 x86_64


def symbolize_inputs(tid):
    rdi = pintool.getCurrentRegisterValue(Triton.registers.rdi)  # argc
    rsi = pintool.getCurrentRegisterValue(Triton.registers.rsi)  # argv

    # argv로 전달된 각 문자열에 대해
    while rdi > 1:
        addr = pintool.getCurrentMemoryValue(
            rsi + ((rdi - 1)*triton.CPUSIZE.QWORD),
            triton.CPUSIZE.QWORD
        )  # 각 기호들에 대해 주소를 가져온다.
        # 현재 매개변수 문자열을 기호화 한다.
        c = None
        s = ''
        while c != 0:
            c = pintool.getCurrentMemoryValue(addr)  # addr의 문자를 읽는다.
            s += chr(c)
            Triton.setConcreteMemoryValue(addr, c)  # addr에 값을 세팅한다.
            Triton.convertMemoryToSymbolicVariable(
                triton.MemoryAccess(addr, triton.CPUSIZE.BYTE).setComment(
                    'argv[%d][%d]' % (rdi - 1), len(s) - 1)
            )  # 현재 addr의 값은 이제 기호 변수로 전환한다.
            addr += 1
        rdi -= 1  # 다음 argv를 분석한다.
        print 'Symbolized argument %d: %s' % (rdi, s)


def hook_icall(insn):
    # 제어 흐름 && 간접호출 주소를 지정하는것인지 확인한다.
    if insn.isControlFlow() and insn.getAddress() == taintedCallsite:
        for op in insn.getOperands():  # operands를 확인한다.
            if op.getType() == triton.OPERAND.REG:  # opearnd의 type이 register라면
                print 'Found tainted indirect call site \'%s\'' % (insn)
                exploit_icall(insn, op)  # exploit 한다.


def exploit_icall(insn, op):
    regId = Triton.getSymbolicRegisterId(op)
    regExpr = Triton.unrollAst(Triton.getAstFromId(regId))
    ast = Triton.getAstContext()

    # 간접 호출 대상 레지스터에 대한 기호 표현식이 target이면 끝
    exploitExpr = ast.equal(regExpr, ast.bv(target, triton.CPUSIZE.QWORD_BIT))

    for k, v in Triton.getSymbolicVariables().iteritems():
        if 'argv' in v.getComment():
            # 매개 변수 문자들은 반드시 출력 가능해야함
            argExpr = Triton.getAstFromId(k)  # 해당 기호 변수의 AST 표현식을 가져온다.
            argExpr = ast.land([
                ast.bvuge(argExpr, ast.bv(32, triton.CPUSIZE.BYTE_BIT)),
                ast.bvule(ast.bv(126, triton.CPUSIZE.BYTE_BIT))
            ])  # 화면에 출력 가능한 범위
            exploitExpr = ast.land([exploitExpr, argExpr])  # 제약 조건 지정

    print 'Getting model for %s -> 0x%x' % (insn, target)
    model = Triton.getModel(exploitExpr) # 제약 조건에 대한 값을 찾는다.
    for k, v in model.iteritems():
        print '%s (%s)' % (v, Triton.getSymbolicVariableFromId(k).getComment())


def main():
    Triton.setArchitecture(triton.ARCH.X86_64)
    Triton.enableMode(triton.MODE.ALIGNED_MEMORY, True)

    pintool.startAnalysisFromSymbol('main')  # Symbol정보가 있는경우에는 사용할수있다.
    # 그러나 Symbol 정보가 없는경우에는 다음과 같이 사용한다.
    # pintool.startAnalysisFromAddress()

    # main함수의 콜백 설치 루틴 -> 사용자의 입력값들을 기호화 시켜 값 찾기
    pintool.insertCall(
        symbolize_inputs, pintool.INSERT_POINT.ROUTINE_ENTRY, 'main')
    # 모든 명령어 수행전 콜백 설치
    pintool.insertCall(hook_icall, pintool.INSERT_POINT.BEFORE)

    pintool.runProgram()


if __name__ == '__main__':
    main()
